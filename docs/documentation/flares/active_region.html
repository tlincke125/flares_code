<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>flares.active_region API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>flares.active_region</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from pathlib import Path
import sys

path_root = Path(__file__).parents[2]
sys.path.append(str(path_root))

from flares.utils import *
from flares.data import *
from flares.fields import ActiveRegionParameters

import torch
import torch.nn.functional as F
from skimage.morphology import square, binary_dilation
from skimage.measure import label
import numpy as np
import networkx as nx
import warnings

from skimage.filters import threshold_local
from skimage.morphology import square
from skimage.measure import label
import matplotlib.pyplot as plt



class ActiveRegion(ActiveRegionParameters):
    def __init__(self, hnum: int, date: datetime, root: str, num_features = 0):
        &#34;&#34;&#34;An Active Region is an entry point into 
        parameterization, segmentation, and graph methods. 

        An Active Region is uniquely determined by it&#39;s harpnumber (hnum) and date (date)
        If the specified active region given (hnum, date) contains a nan, self.valid is False
        (otherwise self.valid is True) and subsequent calls to ActiveRegion methods may fail 
        given the existence of nans. Check status of the active region by self.valid.
        The existence of nan&#39;s implies the image is moving off the solar limb. This is an issue that
        could be turned into a ticket and fixed, but for the time being I am ignoring these images

        Magnetograms and continuums must be organized by the following standard (with root as the root)
        (This standard may be loosened in the future and subsequent documentation will change)

        - root
            - magnetogram
                - sharp_&lt;hnum&gt;
                    - hmi.sharp_cea_720s.&lt;hnum&gt;.&lt;year&gt;&lt;month&gt;&lt;day&gt;_&lt;hour&gt;&lt;minute&gt;&lt;second&gt;_TAI.Bp.fits
                    - hmi.sharp_cea_720s.&lt;hnum&gt;.&lt;year&gt;&lt;month&gt;&lt;day&gt;_&lt;hour&gt;&lt;minute&gt;&lt;second&gt;_TAI.Br.fits
                    - hmi.sharp_cea_720s.&lt;hnum&gt;.&lt;year&gt;&lt;month&gt;&lt;day&gt;_&lt;hour&gt;&lt;minute&gt;&lt;second&gt;_TAI.Bt.fits
            - continuum
                - sharp_&lt;hnum&gt;
                    - hmi.sharp_cea_720s.&lt;hnum&gt;.&lt;year&gt;&lt;month&gt;&lt;day&gt;_&lt;hour&gt;&lt;minute&gt;&lt;second&gt;_TAI.continuum.fits
        
        So for example, (this will work on Swami), a new active region call:
        ```python
        ActiveRegion(7115, datetime(2017, 9, 3, 10), &#34;/srv/data/thli2739&#34;) 
        ```

        Would **require** the following files or symlinks to exist:

        - /srv/data/thli2739
            - /magnetogram
                - /sharp_7115
                    - /hmi.sharp_cea_720s.7115.20170903_100000_TAI.Bp.fits
                    - /hmi.sharp_cea_720s.7115.20170903_100000_TAI.Br.fits
                    - /hmi.sharp_cea_720s.7115.20170903_100000_TAI.Bt.fits
            - /continuum
                - /sharp_7115
                    - /hmi.sharp_cea_720s.7115.20170903_100000_TAI.continuum.fits

        Args:
            hnum (int): The specified harpnumber - file must exist in root/magnetogram/sharp_{hnum} and root/continuum/sharp_{hnum}
            date (datetime): The specified active region date and time - this date must exist in the specified harpnumber data folder 
            root (string): The path to the data. Root must be a directory that holds both root/magnetogram and root/continuum. Inside both
            of these subfolders, there must be a series of folders labeled sharp_{hnum} that contain the sequence of fits files for extraction
        &#34;&#34;&#34;
    
        # Generate xyz components of magnetic field and continuum
        data = get_data(hnum, date, root)

        self.Bz, self.Bx, self.By, self.cont = data[&#34;Bz&#34;], data[&#34;Bx&#34;], data[&#34;By&#34;], data[&#34;cont&#34;]
        
        self.shape = self.Bz.shape
        self.valid = True # Valid is false

        if np.count_nonzero(np.isnan(self.Bz)) / self.Bz.size &gt; 0.0:
            self.valid = False
            warnings.warn(f&#34;Hnum {hnum} date {date} has a nan, skipping&#34;)
            return

        # To prevent nan&#39;s popping up do to small numbers,
        # cut everything below minimum val to minimum val
        minimum_val = 0.001
        self.Bz[np.abs(self.Bz) &lt; minimum_val] = minimum_val
        self.Bx[np.abs(self.Bx) &lt; minimum_val] = minimum_val
        self.By[np.abs(self.By) &lt; minimum_val] = minimum_val

        # Now Bx By Bz are defined so generate the parameter class
        super().__init__(self.Bz, self.By, self.Bx, num_features)

        # The four &#34;segments&#34; as raw arrays (no nodes for graph)
        self.__background = None
        self.__umbra = None
        self.__pumbra = None
        self.__nl = None

        # The Three data sets
        self.__sharps, self.__sharps_labels = np.array(data[&#34;sharps&#34;].values()), list(data[&#34;sharps&#34;].keys())
        self.__baseline, self.__baseline_labels = None, None
        self.__segmented, self.__segmented_labels = np.zeros(4 *  self.num_features), [&#34;&#34; for _ in range(4 * self.num_features)]
        self.__G = nx.Graph()

        # GRAPH DATA
        # Graph data is split between masks and feature vectors. Each &#34;mask&#34; is a node that gets its physical features computed on
        self.__node_masks = np.zeros((0, self.shape[0], self.shape[1]), dtype = bool)
        

    def show_graph(self, axs_cont, axs_seg):
        &#34;&#34;&#34;Plots the continuum next to segmented graph with nodes
        Located on the graph with colors
        
        Note that umbras and penumbras are generally going to be very close to one another
        This is because the umbra is near the center of the penumbra so their centers are going
        to be close - there are a few good examples of nodes that work well - see documentation/guides

        Args:
            axs_cont (axis): The continuum Axis 
            axs_seg (axis): The segmented axis
        &#34;&#34;&#34;
        self.assert_masks()

        color_keys = {&#34;penumbra&#34; : 1.0, &#34;umbra&#34; : 0.5714285714285714, &#34;nl&#34; : 0.0}
        values = [color_keys.get(x[1][&#34;type&#34;], 0.25) for x in self.__G.nodes.data()]
        pos = nx.get_node_attributes(self.__G, &#34;pos&#34;)

        axs_cont.imshow(self.cont)
        nx.draw(self.__G, pos, axs_cont, node_size = 100, cmap = plt.get_cmap(&#39;gray&#39;), node_color = values, with_labels = False, font_color = &#34;white&#34;)
        axs_seg.imshow(self.__umbra | self.__pumbra | self.__nl, cmap = &#34;gray&#34;)
        nx.draw(self.__G, pos, axs_seg, node_size = 100, cmap = plt.get_cmap(&#39;viridis&#39;), node_color = values, with_labels = False, font_color = &#34;white&#34;)

    def draw_graph(self, axs):
        &#34;&#34;&#34;Draws just the graph without a background image of the continuum

        Args:
            axs (pyplot.axis): The axis to write the graph to
        &#34;&#34;&#34;
        self.assert_masks()

        color_keys = {&#34;penumbra&#34; : 1.0, &#34;umbra&#34; : 0.5714285714285714, &#34;nl&#34; : 0.0}
        values = [color_keys.get(x[1][&#34;type&#34;], 0.25) for x in self.__G.nodes.data()]
        nx.draw(self.__G, ax = axs, node_size = 100, cmap = plt.get_cmap(&#39;viridis&#39;), node_color = values, with_labels = False, font_color = &#34;white&#34;)


    def show_umbra(self, axs_orig, axs_seg):
        &#34;&#34;&#34;Shows the umbra segmented next to the continuum

        Args:
            axs_orig (matplotlib axis): The axis for the unsegmented image
            axs_seg (matplotlib axis): The axis for the segmented image
        &#34;&#34;&#34;
        self.assert_masks()
        axs_orig.imshow(self.cont, cmap = &#34;gray&#34;)
        axs_seg.imshow(~self.__umbra, cmap = &#34;gray&#34;)
        axs_orig.axis(False)
        axs_seg.axis(False)
    
    def show_neutral_line(self, axs_orig, axs_seg):
        &#34;&#34;&#34;Shows the neutral line segmented next to the line of sight magnetic field

        Args:
            axs_orig (matplotlib axis): The axis for the unsegmented image
            axs_seg (matplotlib axis): The axis for the segmented image
        &#34;&#34;&#34;
        self.assert_masks()
        axs_orig.imshow(self.Bz, cmap = &#34;gray&#34;)
        axs_seg.imshow(~self.__nl, cmap = &#34;gray&#34;)
        axs_orig.axis(False)
        axs_seg.axis(False)

    def show_penumbra(self, axs_orig, axs_seg):
        &#34;&#34;&#34;Shows the penumbra segmented next to the continuum

        Args:
            axs_orig (matplotlib axis): The axis for the unsegmented image
            axs_seg (matplotlib axis): The axis for the segmented image
        &#34;&#34;&#34;
        self.assert_masks()
        axs_orig.imshow(self.cont, cmap = &#34;gray&#34;)
        axs_seg.imshow(~self.__pumbra, cmap = &#34;gray&#34;)
        axs_orig.axis(False)
        axs_seg.axis(False)

    def show_background(self, axs_orig, axs_seg):
        &#34;&#34;&#34;Shows the background segmented next to the continuum

        Args:
            axs_orig (matplotlib axis): The axis for the unsegmented image
            axs_seg (matplotlib axis): The axis for the segmented image
        &#34;&#34;&#34;
        self.assert_masks()
        axs_orig.imshow(self.cont, cmap = &#34;gray&#34;)
        axs_seg.imshow(~self.__background, cmap = &#34;gray&#34;)
        axs_orig.axis(False)
        axs_seg.axis(False)

    def get_graph(self):
        &#34;&#34;&#34;Gets the sharps data and labels

        Sharps data is the data JSOC calculates - good baseline

        Returns:
            data, labels
        &#34;&#34;&#34;
        self.assert_masks()
        self.__G_labels = self.__baseline_labels # Just a copy of baseline
        return self.__G, self.__G_labels

    def get_sharps(self):
        &#34;&#34;&#34;Gets the sharps data and labels

        Sharps data is the data JSOC calculates - good baseline

        Returns:
            data, labels
        &#34;&#34;&#34;
        self.assert_masks()
        return self.__sharps, self.__sharps_labels

    def get_baseline(self):
        &#34;&#34;&#34;Get function for baseline

        Returns:
            numpy array: baseline data set
        &#34;&#34;&#34;
        self.assert_masks()
        return self.__baseline, self.__baseline_labels

    def get_segmented(self):
        &#34;&#34;&#34;Get function for segmented

        Returns:
            numpy array: segmented data set 
        &#34;&#34;&#34;
        self.assert_masks()
        return self.__segmented, self.__segmented_labels

    def assert_masks(self):
        &#34;&#34;&#34;One function that generates all three masks. If all three masks are already
        generated, this function does nothing
        &#34;&#34;&#34;
        self.__baseline, self.__baseline_labels = self.physical_features(np.ones(self.shape, dtype = bool), &#34;bas_&#34;)
        self.assert_neutral_lines()
        self.assert_umbra_pumbra()
        self.assert_background()

    
    def assert_background(self):
        &#34;&#34;&#34;Generates a background mask. If background is already generated, does nothing
        Background is simply $$\\neg (Umbra \\cup Penumbra \\cup Neutral Line)$$
        &#34;&#34;&#34;
        if self.__background is None:
            self.__background = torch.zeros(self.shape, dtype=bool)
            self.assert_neutral_lines()
            self.assert_umbra_pumbra()

            background = ~(self.__nl | self.__umbra | self.__pumbra)

            # Update dataset
            data, labels = self.physical_features(background, &#34;bckg_&#34;)
            self.__segmented[3*self.num_features:4*self.num_features] = data
            self.__segmented_labels[3*self.num_features:4*self.num_features] = labels

            self.__background = background

    def assert_neutral_lines(self, radius = 3, thresh = 150):
        &#34;&#34;&#34;Generates neutral lines using morphological operations and a flux threshold
        finds neutral lines using the method described by Schrijver in
        
        **C. J. Schrijver. A characteristic magnetic field pattern associated with all major solar flares and its use in flare forecasting. *The Astrophysical Journal, 655(2), 2007.***


        Args:
            radius (int, optional): The found neutral line is one pixel thick, so dilating it slightly adds the surrounding neighborhood. This radius
            is passed to sklearn.morphology.square(radius) in the call to sklearn.morphology.binary_dilation. Defaults to 3
            thresh (int, optional): Flux threshold. Defaults to 150 (as used by Schjriver et. al).
        &#34;&#34;&#34;
        if self.__nl is None:
            # Find neutral Lines
            nl_mask = binary_dilation(self.Bz &lt; -thresh, square(radius)) &amp; binary_dilation(self.Bz &gt; thresh, square(radius))


            labeled, labels, sizes = self.__group_pixels(nl_mask)
            labels, sizes = self.__remove_small_groups(labeled, labels, sizes, 10)
            labels, sizes = self.__remove_percentage_max(labeled, labels, sizes)
            labels, sizes = self.__largest_n_clusters(labels, sizes)

            # Add all the graph nodes
            nl_mask = np.zeros(self.shape, dtype = bool)
            cur_node = len(self.__node_masks)

            if len(sizes) == 0:
                self.__segmented[0:self.num_features] = 0
                self.__nl = nl_mask
                return

            for i in labels:
                mask = labeled == i
                cur_node = self.__ar_add_node(self.physical_features(mask)[0], cur_node, mask, &#34;neutral line&#34;)
                nl_mask |= mask

            # Compute the segmented data set
            data, labels = self.physical_features(nl_mask, &#34;nl_&#34;)
            self.__segmented[0:self.num_features] = data
            self.__segmented_labels[0:self.num_features] = labels
            self.__nl = nl_mask

    

    def assert_umbra_pumbra(self):
        &#34;&#34;&#34;An original algorithm for detecting umbras and penumbras from a continuum image

        High Level Algorithm:

        1. bound continuum between 0 and 255

        2. use an adaptive filter on the bounded continuum

        3. group and label touching pixels 

        4. remove groups of pixels that are less than 500 from those remaining (if any) 

        5. remove groups of pixels that border the image (usually noise) from those remaining (if any) 

        6. remove all groups that are smaller than 10% of the size of the maximum group size from those remaining (if any)  

        7. remove take the largest 6 clusters from those remaining (if any) 

        8. The remaining groups are **penumbra outlines**, repeat the above process isolated only to the penumbra outlines
        if the difference between maximum and minimum flux in the mask is greater than 21000 and the resulting clusters are umbras

        9. Keep the remaining 6 largest umbras
        &#34;&#34;&#34;
        if self.__pumbra is None or self.__umbra is None:
            #We first segment large groups (that may be penumbras or umbras)
            cont_bounded = (255 * (self.cont - np.min(self.cont)) / np.ptp(self.cont)).astype(np.uint8)
 
            block_size = np.min(self.shape)
            if block_size % 2 == 0:
                block_size -= 1
                
            offset = 10
            binary_adaptive = cont_bounded &lt; (threshold_local(cont_bounded, block_size, offset = offset) - offset)

            labeled_0, labels, sizes = self.__group_pixels(binary_adaptive)
            labels, sizes = self.__remove_small_groups(labeled_0, labels, sizes)
            labels, sizes = self.__remove_bordering_pixels(labeled_0, labels, sizes)
            labels, sizes = self.__remove_percentage_max(labeled_0, labels, sizes)
            labels, sizes = self.__largest_n_clusters(labels, sizes)

            um_mask = np.zeros(self.shape, dtype = bool)
            pu_mask = np.zeros(self.shape, dtype = bool)
            cur_node = 0

            if len(sizes) == 0:
                self.__segmented[self.num_features:2*self.num_features] = 0
                self.__segmented[2*self.num_features:3*self.num_features] = 0
                self.__umbra = um_mask
                self.__pumbra = pu_mask
                return

            # For each large group - determine if this is a penumbra / umbra combo or just umbra
            for i in labels:
                mask = labeled_0 == i
                mx = np.max(self.cont[mask])
                mn = np.min(self.cont[mask])
                t = (mx - mn) / 2 + mn

                # PENUMBRA AND UMBRA
                if mx - mn &gt; 21000:
                    # Both umbra and penumbra
                    um = mask &amp; (self.cont &lt;= t)
                    pu = mask &amp; (self.cont &gt; t)


                    # Further segment the umbra node again
                    labeled, labels, sizes = self.__group_pixels(pu)
                    labels, sizes = self.__remove_small_groups(labeled, labels, sizes, 10)
                    labels, sizes = self.__remove_percentage_max(labeled, labels, sizes)
                    labels, sizes = self.__largest_n_clusters(labels, sizes)

                    for i in labels:
                        mask = labeled == i
                        cur_node = self.__ar_add_node(self.physical_features(mask)[0], cur_node, mask, &#34;penumbra&#34;)
                        pu_mask |= mask

                    # Further segment the umbra node again
                    labeled, labels, sizes = self.__group_pixels(um)
                    labels, sizes = self.__remove_small_groups(labeled, labels, sizes, 10)
                    labels, sizes = self.__remove_percentage_max(labeled, labels, sizes)
                    labels, sizes = self.__largest_n_clusters(labels, sizes)

                    for i in labels:
                        mask = labeled == i
                        cur_node = self.__ar_add_node(self.physical_features(mask)[0], cur_node, mask, &#34;umbra&#34;)
                        um_mask |= mask

                # ONLY UMBRA
                else:
                    um = mask &amp; (self.cont &lt;= t)
                    cur_node = self.__ar_add_node(self.physical_features(mask)[0], cur_node, mask, &#34;umbra&#34;)
                    um_mask |= um
            
            # Compute the segmented data set
            data, labels = self.physical_features(um_mask, &#34;um_&#34;)
            self.__segmented[self.num_features:2*self.num_features] = data
            self.__segmented_labels[self.num_features:2*self.num_features] = labels

            data, labels = self.physical_features(um_mask, &#34;pu_&#34;)
            self.__segmented[2*self.num_features:3*self.num_features] = data
            self.__segmented_labels[2*self.num_features:3*self.num_features] = labels

            self.__umbra = um_mask
            self.__pumbra = pu_mask

    def __group_pixels(self, mask):
        &#34;&#34;&#34;Groups pixels in a binary mask based on if they are touching

        Args:
            mask (np.array): A mask with binary pixels

        Returns:
            labeled: a mask that is labeled from 0 to number of groups (0 is the background) the size of the number in the label doesn&#39;t mean anything
            labels: a list of labels in labeled
            sizes: a list of sizes corresponding to each element in labels
        &#34;&#34;&#34;
        labeled = label(mask, connectivity = 2)
        labels = np.unique(labeled)[1:]
        sizes = np.array([np.count_nonzero(labeled==i) for i in labels])
        return labeled, labels, sizes

    def __remove_small_groups(self, labeled: np.array, labels: np.array, sizes: np.array, p = 500):
        &#34;&#34;&#34;Removes groups of pixels smaller than p

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        filt = np.argwhere((sizes &lt; p))
        return np.delete(labels, filt), np.delete(sizes, filt)

    def __remove_bordering_pixels(self, labeled: np.array, labels: np.array, sizes: np.array):
        &#34;&#34;&#34;Removes pixels that border the edge

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        bordered = []
        for i in range(len(labels)):
            rows, cols = np.where(labeled == labels[i])
            if min(rows) == 0 or min(cols) == 0:
                bordered.append(i)
            if max(cols) == self.shape[1] - 1 or max(rows) == self.shape[0] - 1:
                bordered.append(i)
        return np.delete(labels, bordered), np.delete(sizes, bordered)

    def __remove_percentage_max(self, labeled, labels, sizes, p = 0.1):
        &#34;&#34;&#34;Removes pixels that border the edge

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        filt = np.argwhere(sizes &lt; p * np.max(sizes))
        return np.delete(labels, filt), np.delete(sizes, filt)

    def __largest_n_clusters(self, labels, sizes, n = 6):
        &#34;&#34;&#34;Removes pixels that border the edge

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        n = min(n, len(labels))
        a = np.partition(sizes, -n)[-n]
        return labels[sizes &gt;= a], sizes[sizes &gt;= a]

    def __ar_add_node(self, data, cur_node, mask, type):
        &#34;&#34;&#34;Adds a node to self graph and connects to all the previous nodes

        Args:
            data ([type]): [description]
            cur_node ([type]): [description]
            mask ([type]): [description]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        # Get the center of the node for plotting
        x, y = np.where(mask)
        x, y = int(np.mean(x)), int(np.mean(y))

        self.__G.add_node(cur_node, v = data, pos = (y,x), type = type)
        #self.__G.add_node(cur_node, v = data, pos = (0,100), type = type)

        mask_dil = binary_dilation(mask, square(3))

        for m in range(len(self.__node_masks)):
            if np.count_nonzero(mask_dil &amp; self.__node_masks[m]) &gt; 0:
                self.__G.add_edge(cur_node, m)

        self.__node_masks = np.concatenate((self.__node_masks, mask_dil[None,...]), axis = 0)
        return cur_node + 1

    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="flares.active_region.ActiveRegion"><code class="flex name class">
<span>class <span class="ident">ActiveRegion</span></span>
<span>(</span><span>hnum: int, date: datetime.datetime, root: str, num_features=0)</span>
</code></dt>
<dd>
<div class="desc"><p>An Active Region is an entry point into
parameterization, segmentation, and graph methods. </p>
<p>An Active Region is uniquely determined by it's harpnumber (hnum) and date (date)
If the specified active region given (hnum, date) contains a nan, self.valid is False
(otherwise self.valid is True) and subsequent calls to ActiveRegion methods may fail
given the existence of nans. Check status of the active region by self.valid.
The existence of nan's implies the image is moving off the solar limb. This is an issue that
could be turned into a ticket and fixed, but for the time being I am ignoring these images</p>
<p>Magnetograms and continuums must be organized by the following standard (with root as the root)
(This standard may be loosened in the future and subsequent documentation will change)</p>
<ul>
<li>root<ul>
<li>magnetogram<ul>
<li>sharp_<hnum><ul>
<li>hmi.sharp_cea_720s.<hnum>.<year><month><day>_<hour><minute><second>_TAI.Bp.fits</li>
<li>hmi.sharp_cea_720s.<hnum>.<year><month><day>_<hour><minute><second>_TAI.Br.fits</li>
<li>hmi.sharp_cea_720s.<hnum>.<year><month><day>_<hour><minute><second>_TAI.Bt.fits</li>
</ul>
</li>
</ul>
</li>
<li>continuum<ul>
<li>sharp_<hnum><ul>
<li>hmi.sharp_cea_720s.<hnum>.<year><month><day>_<hour><minute><second>_TAI.continuum.fits</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>So for example, (this will work on Swami), a new active region call:</p>
<pre><code class="language-python">ActiveRegion(7115, datetime(2017, 9, 3, 10), &quot;/srv/data/thli2739&quot;) 
</code></pre>
<p>Would <strong>require</strong> the following files or symlinks to exist:</p>
<ul>
<li>/srv/data/thli2739<ul>
<li>/magnetogram<ul>
<li>/sharp_7115<ul>
<li>/hmi.sharp_cea_720s.7115.20170903_100000_TAI.Bp.fits</li>
<li>/hmi.sharp_cea_720s.7115.20170903_100000_TAI.Br.fits</li>
<li>/hmi.sharp_cea_720s.7115.20170903_100000_TAI.Bt.fits</li>
</ul>
</li>
</ul>
</li>
<li>/continuum<ul>
<li>/sharp_7115<ul>
<li>/hmi.sharp_cea_720s.7115.20170903_100000_TAI.continuum.fits</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hnum</code></strong> :&ensp;<code>int</code></dt>
<dd>The specified harpnumber - file must exist in root/magnetogram/sharp_{hnum} and root/continuum/sharp_{hnum}</dd>
<dt><strong><code>date</code></strong> :&ensp;<code>datetime</code></dt>
<dd>The specified active region date and time - this date must exist in the specified harpnumber data folder </dd>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>The path to the data. Root must be a directory that holds both root/magnetogram and root/continuum. Inside both</dd>
</dl>
<p>of these subfolders, there must be a series of folders labeled sharp_{hnum} that contain the sequence of fits files for extraction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActiveRegion(ActiveRegionParameters):
    def __init__(self, hnum: int, date: datetime, root: str, num_features = 0):
        &#34;&#34;&#34;An Active Region is an entry point into 
        parameterization, segmentation, and graph methods. 

        An Active Region is uniquely determined by it&#39;s harpnumber (hnum) and date (date)
        If the specified active region given (hnum, date) contains a nan, self.valid is False
        (otherwise self.valid is True) and subsequent calls to ActiveRegion methods may fail 
        given the existence of nans. Check status of the active region by self.valid.
        The existence of nan&#39;s implies the image is moving off the solar limb. This is an issue that
        could be turned into a ticket and fixed, but for the time being I am ignoring these images

        Magnetograms and continuums must be organized by the following standard (with root as the root)
        (This standard may be loosened in the future and subsequent documentation will change)

        - root
            - magnetogram
                - sharp_&lt;hnum&gt;
                    - hmi.sharp_cea_720s.&lt;hnum&gt;.&lt;year&gt;&lt;month&gt;&lt;day&gt;_&lt;hour&gt;&lt;minute&gt;&lt;second&gt;_TAI.Bp.fits
                    - hmi.sharp_cea_720s.&lt;hnum&gt;.&lt;year&gt;&lt;month&gt;&lt;day&gt;_&lt;hour&gt;&lt;minute&gt;&lt;second&gt;_TAI.Br.fits
                    - hmi.sharp_cea_720s.&lt;hnum&gt;.&lt;year&gt;&lt;month&gt;&lt;day&gt;_&lt;hour&gt;&lt;minute&gt;&lt;second&gt;_TAI.Bt.fits
            - continuum
                - sharp_&lt;hnum&gt;
                    - hmi.sharp_cea_720s.&lt;hnum&gt;.&lt;year&gt;&lt;month&gt;&lt;day&gt;_&lt;hour&gt;&lt;minute&gt;&lt;second&gt;_TAI.continuum.fits
        
        So for example, (this will work on Swami), a new active region call:
        ```python
        ActiveRegion(7115, datetime(2017, 9, 3, 10), &#34;/srv/data/thli2739&#34;) 
        ```

        Would **require** the following files or symlinks to exist:

        - /srv/data/thli2739
            - /magnetogram
                - /sharp_7115
                    - /hmi.sharp_cea_720s.7115.20170903_100000_TAI.Bp.fits
                    - /hmi.sharp_cea_720s.7115.20170903_100000_TAI.Br.fits
                    - /hmi.sharp_cea_720s.7115.20170903_100000_TAI.Bt.fits
            - /continuum
                - /sharp_7115
                    - /hmi.sharp_cea_720s.7115.20170903_100000_TAI.continuum.fits

        Args:
            hnum (int): The specified harpnumber - file must exist in root/magnetogram/sharp_{hnum} and root/continuum/sharp_{hnum}
            date (datetime): The specified active region date and time - this date must exist in the specified harpnumber data folder 
            root (string): The path to the data. Root must be a directory that holds both root/magnetogram and root/continuum. Inside both
            of these subfolders, there must be a series of folders labeled sharp_{hnum} that contain the sequence of fits files for extraction
        &#34;&#34;&#34;
    
        # Generate xyz components of magnetic field and continuum
        data = get_data(hnum, date, root)

        self.Bz, self.Bx, self.By, self.cont = data[&#34;Bz&#34;], data[&#34;Bx&#34;], data[&#34;By&#34;], data[&#34;cont&#34;]
        
        self.shape = self.Bz.shape
        self.valid = True # Valid is false

        if np.count_nonzero(np.isnan(self.Bz)) / self.Bz.size &gt; 0.0:
            self.valid = False
            warnings.warn(f&#34;Hnum {hnum} date {date} has a nan, skipping&#34;)
            return

        # To prevent nan&#39;s popping up do to small numbers,
        # cut everything below minimum val to minimum val
        minimum_val = 0.001
        self.Bz[np.abs(self.Bz) &lt; minimum_val] = minimum_val
        self.Bx[np.abs(self.Bx) &lt; minimum_val] = minimum_val
        self.By[np.abs(self.By) &lt; minimum_val] = minimum_val

        # Now Bx By Bz are defined so generate the parameter class
        super().__init__(self.Bz, self.By, self.Bx, num_features)

        # The four &#34;segments&#34; as raw arrays (no nodes for graph)
        self.__background = None
        self.__umbra = None
        self.__pumbra = None
        self.__nl = None

        # The Three data sets
        self.__sharps, self.__sharps_labels = np.array(data[&#34;sharps&#34;].values()), list(data[&#34;sharps&#34;].keys())
        self.__baseline, self.__baseline_labels = None, None
        self.__segmented, self.__segmented_labels = np.zeros(4 *  self.num_features), [&#34;&#34; for _ in range(4 * self.num_features)]
        self.__G = nx.Graph()

        # GRAPH DATA
        # Graph data is split between masks and feature vectors. Each &#34;mask&#34; is a node that gets its physical features computed on
        self.__node_masks = np.zeros((0, self.shape[0], self.shape[1]), dtype = bool)
        

    def show_graph(self, axs_cont, axs_seg):
        &#34;&#34;&#34;Plots the continuum next to segmented graph with nodes
        Located on the graph with colors
        
        Note that umbras and penumbras are generally going to be very close to one another
        This is because the umbra is near the center of the penumbra so their centers are going
        to be close - there are a few good examples of nodes that work well - see documentation/guides

        Args:
            axs_cont (axis): The continuum Axis 
            axs_seg (axis): The segmented axis
        &#34;&#34;&#34;
        self.assert_masks()

        color_keys = {&#34;penumbra&#34; : 1.0, &#34;umbra&#34; : 0.5714285714285714, &#34;nl&#34; : 0.0}
        values = [color_keys.get(x[1][&#34;type&#34;], 0.25) for x in self.__G.nodes.data()]
        pos = nx.get_node_attributes(self.__G, &#34;pos&#34;)

        axs_cont.imshow(self.cont)
        nx.draw(self.__G, pos, axs_cont, node_size = 100, cmap = plt.get_cmap(&#39;gray&#39;), node_color = values, with_labels = False, font_color = &#34;white&#34;)
        axs_seg.imshow(self.__umbra | self.__pumbra | self.__nl, cmap = &#34;gray&#34;)
        nx.draw(self.__G, pos, axs_seg, node_size = 100, cmap = plt.get_cmap(&#39;viridis&#39;), node_color = values, with_labels = False, font_color = &#34;white&#34;)

    def draw_graph(self, axs):
        &#34;&#34;&#34;Draws just the graph without a background image of the continuum

        Args:
            axs (pyplot.axis): The axis to write the graph to
        &#34;&#34;&#34;
        self.assert_masks()

        color_keys = {&#34;penumbra&#34; : 1.0, &#34;umbra&#34; : 0.5714285714285714, &#34;nl&#34; : 0.0}
        values = [color_keys.get(x[1][&#34;type&#34;], 0.25) for x in self.__G.nodes.data()]
        nx.draw(self.__G, ax = axs, node_size = 100, cmap = plt.get_cmap(&#39;viridis&#39;), node_color = values, with_labels = False, font_color = &#34;white&#34;)


    def show_umbra(self, axs_orig, axs_seg):
        &#34;&#34;&#34;Shows the umbra segmented next to the continuum

        Args:
            axs_orig (matplotlib axis): The axis for the unsegmented image
            axs_seg (matplotlib axis): The axis for the segmented image
        &#34;&#34;&#34;
        self.assert_masks()
        axs_orig.imshow(self.cont, cmap = &#34;gray&#34;)
        axs_seg.imshow(~self.__umbra, cmap = &#34;gray&#34;)
        axs_orig.axis(False)
        axs_seg.axis(False)
    
    def show_neutral_line(self, axs_orig, axs_seg):
        &#34;&#34;&#34;Shows the neutral line segmented next to the line of sight magnetic field

        Args:
            axs_orig (matplotlib axis): The axis for the unsegmented image
            axs_seg (matplotlib axis): The axis for the segmented image
        &#34;&#34;&#34;
        self.assert_masks()
        axs_orig.imshow(self.Bz, cmap = &#34;gray&#34;)
        axs_seg.imshow(~self.__nl, cmap = &#34;gray&#34;)
        axs_orig.axis(False)
        axs_seg.axis(False)

    def show_penumbra(self, axs_orig, axs_seg):
        &#34;&#34;&#34;Shows the penumbra segmented next to the continuum

        Args:
            axs_orig (matplotlib axis): The axis for the unsegmented image
            axs_seg (matplotlib axis): The axis for the segmented image
        &#34;&#34;&#34;
        self.assert_masks()
        axs_orig.imshow(self.cont, cmap = &#34;gray&#34;)
        axs_seg.imshow(~self.__pumbra, cmap = &#34;gray&#34;)
        axs_orig.axis(False)
        axs_seg.axis(False)

    def show_background(self, axs_orig, axs_seg):
        &#34;&#34;&#34;Shows the background segmented next to the continuum

        Args:
            axs_orig (matplotlib axis): The axis for the unsegmented image
            axs_seg (matplotlib axis): The axis for the segmented image
        &#34;&#34;&#34;
        self.assert_masks()
        axs_orig.imshow(self.cont, cmap = &#34;gray&#34;)
        axs_seg.imshow(~self.__background, cmap = &#34;gray&#34;)
        axs_orig.axis(False)
        axs_seg.axis(False)

    def get_graph(self):
        &#34;&#34;&#34;Gets the sharps data and labels

        Sharps data is the data JSOC calculates - good baseline

        Returns:
            data, labels
        &#34;&#34;&#34;
        self.assert_masks()
        self.__G_labels = self.__baseline_labels # Just a copy of baseline
        return self.__G, self.__G_labels

    def get_sharps(self):
        &#34;&#34;&#34;Gets the sharps data and labels

        Sharps data is the data JSOC calculates - good baseline

        Returns:
            data, labels
        &#34;&#34;&#34;
        self.assert_masks()
        return self.__sharps, self.__sharps_labels

    def get_baseline(self):
        &#34;&#34;&#34;Get function for baseline

        Returns:
            numpy array: baseline data set
        &#34;&#34;&#34;
        self.assert_masks()
        return self.__baseline, self.__baseline_labels

    def get_segmented(self):
        &#34;&#34;&#34;Get function for segmented

        Returns:
            numpy array: segmented data set 
        &#34;&#34;&#34;
        self.assert_masks()
        return self.__segmented, self.__segmented_labels

    def assert_masks(self):
        &#34;&#34;&#34;One function that generates all three masks. If all three masks are already
        generated, this function does nothing
        &#34;&#34;&#34;
        self.__baseline, self.__baseline_labels = self.physical_features(np.ones(self.shape, dtype = bool), &#34;bas_&#34;)
        self.assert_neutral_lines()
        self.assert_umbra_pumbra()
        self.assert_background()

    
    def assert_background(self):
        &#34;&#34;&#34;Generates a background mask. If background is already generated, does nothing
        Background is simply $$\\neg (Umbra \\cup Penumbra \\cup Neutral Line)$$
        &#34;&#34;&#34;
        if self.__background is None:
            self.__background = torch.zeros(self.shape, dtype=bool)
            self.assert_neutral_lines()
            self.assert_umbra_pumbra()

            background = ~(self.__nl | self.__umbra | self.__pumbra)

            # Update dataset
            data, labels = self.physical_features(background, &#34;bckg_&#34;)
            self.__segmented[3*self.num_features:4*self.num_features] = data
            self.__segmented_labels[3*self.num_features:4*self.num_features] = labels

            self.__background = background

    def assert_neutral_lines(self, radius = 3, thresh = 150):
        &#34;&#34;&#34;Generates neutral lines using morphological operations and a flux threshold
        finds neutral lines using the method described by Schrijver in
        
        **C. J. Schrijver. A characteristic magnetic field pattern associated with all major solar flares and its use in flare forecasting. *The Astrophysical Journal, 655(2), 2007.***


        Args:
            radius (int, optional): The found neutral line is one pixel thick, so dilating it slightly adds the surrounding neighborhood. This radius
            is passed to sklearn.morphology.square(radius) in the call to sklearn.morphology.binary_dilation. Defaults to 3
            thresh (int, optional): Flux threshold. Defaults to 150 (as used by Schjriver et. al).
        &#34;&#34;&#34;
        if self.__nl is None:
            # Find neutral Lines
            nl_mask = binary_dilation(self.Bz &lt; -thresh, square(radius)) &amp; binary_dilation(self.Bz &gt; thresh, square(radius))


            labeled, labels, sizes = self.__group_pixels(nl_mask)
            labels, sizes = self.__remove_small_groups(labeled, labels, sizes, 10)
            labels, sizes = self.__remove_percentage_max(labeled, labels, sizes)
            labels, sizes = self.__largest_n_clusters(labels, sizes)

            # Add all the graph nodes
            nl_mask = np.zeros(self.shape, dtype = bool)
            cur_node = len(self.__node_masks)

            if len(sizes) == 0:
                self.__segmented[0:self.num_features] = 0
                self.__nl = nl_mask
                return

            for i in labels:
                mask = labeled == i
                cur_node = self.__ar_add_node(self.physical_features(mask)[0], cur_node, mask, &#34;neutral line&#34;)
                nl_mask |= mask

            # Compute the segmented data set
            data, labels = self.physical_features(nl_mask, &#34;nl_&#34;)
            self.__segmented[0:self.num_features] = data
            self.__segmented_labels[0:self.num_features] = labels
            self.__nl = nl_mask

    

    def assert_umbra_pumbra(self):
        &#34;&#34;&#34;An original algorithm for detecting umbras and penumbras from a continuum image

        High Level Algorithm:

        1. bound continuum between 0 and 255

        2. use an adaptive filter on the bounded continuum

        3. group and label touching pixels 

        4. remove groups of pixels that are less than 500 from those remaining (if any) 

        5. remove groups of pixels that border the image (usually noise) from those remaining (if any) 

        6. remove all groups that are smaller than 10% of the size of the maximum group size from those remaining (if any)  

        7. remove take the largest 6 clusters from those remaining (if any) 

        8. The remaining groups are **penumbra outlines**, repeat the above process isolated only to the penumbra outlines
        if the difference between maximum and minimum flux in the mask is greater than 21000 and the resulting clusters are umbras

        9. Keep the remaining 6 largest umbras
        &#34;&#34;&#34;
        if self.__pumbra is None or self.__umbra is None:
            #We first segment large groups (that may be penumbras or umbras)
            cont_bounded = (255 * (self.cont - np.min(self.cont)) / np.ptp(self.cont)).astype(np.uint8)
 
            block_size = np.min(self.shape)
            if block_size % 2 == 0:
                block_size -= 1
                
            offset = 10
            binary_adaptive = cont_bounded &lt; (threshold_local(cont_bounded, block_size, offset = offset) - offset)

            labeled_0, labels, sizes = self.__group_pixels(binary_adaptive)
            labels, sizes = self.__remove_small_groups(labeled_0, labels, sizes)
            labels, sizes = self.__remove_bordering_pixels(labeled_0, labels, sizes)
            labels, sizes = self.__remove_percentage_max(labeled_0, labels, sizes)
            labels, sizes = self.__largest_n_clusters(labels, sizes)

            um_mask = np.zeros(self.shape, dtype = bool)
            pu_mask = np.zeros(self.shape, dtype = bool)
            cur_node = 0

            if len(sizes) == 0:
                self.__segmented[self.num_features:2*self.num_features] = 0
                self.__segmented[2*self.num_features:3*self.num_features] = 0
                self.__umbra = um_mask
                self.__pumbra = pu_mask
                return

            # For each large group - determine if this is a penumbra / umbra combo or just umbra
            for i in labels:
                mask = labeled_0 == i
                mx = np.max(self.cont[mask])
                mn = np.min(self.cont[mask])
                t = (mx - mn) / 2 + mn

                # PENUMBRA AND UMBRA
                if mx - mn &gt; 21000:
                    # Both umbra and penumbra
                    um = mask &amp; (self.cont &lt;= t)
                    pu = mask &amp; (self.cont &gt; t)


                    # Further segment the umbra node again
                    labeled, labels, sizes = self.__group_pixels(pu)
                    labels, sizes = self.__remove_small_groups(labeled, labels, sizes, 10)
                    labels, sizes = self.__remove_percentage_max(labeled, labels, sizes)
                    labels, sizes = self.__largest_n_clusters(labels, sizes)

                    for i in labels:
                        mask = labeled == i
                        cur_node = self.__ar_add_node(self.physical_features(mask)[0], cur_node, mask, &#34;penumbra&#34;)
                        pu_mask |= mask

                    # Further segment the umbra node again
                    labeled, labels, sizes = self.__group_pixels(um)
                    labels, sizes = self.__remove_small_groups(labeled, labels, sizes, 10)
                    labels, sizes = self.__remove_percentage_max(labeled, labels, sizes)
                    labels, sizes = self.__largest_n_clusters(labels, sizes)

                    for i in labels:
                        mask = labeled == i
                        cur_node = self.__ar_add_node(self.physical_features(mask)[0], cur_node, mask, &#34;umbra&#34;)
                        um_mask |= mask

                # ONLY UMBRA
                else:
                    um = mask &amp; (self.cont &lt;= t)
                    cur_node = self.__ar_add_node(self.physical_features(mask)[0], cur_node, mask, &#34;umbra&#34;)
                    um_mask |= um
            
            # Compute the segmented data set
            data, labels = self.physical_features(um_mask, &#34;um_&#34;)
            self.__segmented[self.num_features:2*self.num_features] = data
            self.__segmented_labels[self.num_features:2*self.num_features] = labels

            data, labels = self.physical_features(um_mask, &#34;pu_&#34;)
            self.__segmented[2*self.num_features:3*self.num_features] = data
            self.__segmented_labels[2*self.num_features:3*self.num_features] = labels

            self.__umbra = um_mask
            self.__pumbra = pu_mask

    def __group_pixels(self, mask):
        &#34;&#34;&#34;Groups pixels in a binary mask based on if they are touching

        Args:
            mask (np.array): A mask with binary pixels

        Returns:
            labeled: a mask that is labeled from 0 to number of groups (0 is the background) the size of the number in the label doesn&#39;t mean anything
            labels: a list of labels in labeled
            sizes: a list of sizes corresponding to each element in labels
        &#34;&#34;&#34;
        labeled = label(mask, connectivity = 2)
        labels = np.unique(labeled)[1:]
        sizes = np.array([np.count_nonzero(labeled==i) for i in labels])
        return labeled, labels, sizes

    def __remove_small_groups(self, labeled: np.array, labels: np.array, sizes: np.array, p = 500):
        &#34;&#34;&#34;Removes groups of pixels smaller than p

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        filt = np.argwhere((sizes &lt; p))
        return np.delete(labels, filt), np.delete(sizes, filt)

    def __remove_bordering_pixels(self, labeled: np.array, labels: np.array, sizes: np.array):
        &#34;&#34;&#34;Removes pixels that border the edge

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        bordered = []
        for i in range(len(labels)):
            rows, cols = np.where(labeled == labels[i])
            if min(rows) == 0 or min(cols) == 0:
                bordered.append(i)
            if max(cols) == self.shape[1] - 1 or max(rows) == self.shape[0] - 1:
                bordered.append(i)
        return np.delete(labels, bordered), np.delete(sizes, bordered)

    def __remove_percentage_max(self, labeled, labels, sizes, p = 0.1):
        &#34;&#34;&#34;Removes pixels that border the edge

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        filt = np.argwhere(sizes &lt; p * np.max(sizes))
        return np.delete(labels, filt), np.delete(sizes, filt)

    def __largest_n_clusters(self, labels, sizes, n = 6):
        &#34;&#34;&#34;Removes pixels that border the edge

        Args:
            labeled (np.array): The labeled array returned from group_pixels
            labels (np.array): The distinct labels found in labeled
            sizes (np.array): The size of each label in labels
            p (int, optional): Smallest group size. Defaults to 500.

        Returns:
            labels: Labels filtered 
            sizes: sizes filtered 
        &#34;&#34;&#34;
        if len(sizes) == 0:
            return labels, sizes
        n = min(n, len(labels))
        a = np.partition(sizes, -n)[-n]
        return labels[sizes &gt;= a], sizes[sizes &gt;= a]

    def __ar_add_node(self, data, cur_node, mask, type):
        &#34;&#34;&#34;Adds a node to self graph and connects to all the previous nodes

        Args:
            data ([type]): [description]
            cur_node ([type]): [description]
            mask ([type]): [description]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        # Get the center of the node for plotting
        x, y = np.where(mask)
        x, y = int(np.mean(x)), int(np.mean(y))

        self.__G.add_node(cur_node, v = data, pos = (y,x), type = type)
        #self.__G.add_node(cur_node, v = data, pos = (0,100), type = type)

        mask_dil = binary_dilation(mask, square(3))

        for m in range(len(self.__node_masks)):
            if np.count_nonzero(mask_dil &amp; self.__node_masks[m]) &gt; 0:
                self.__G.add_edge(cur_node, m)

        self.__node_masks = np.concatenate((self.__node_masks, mask_dil[None,...]), axis = 0)
        return cur_node + 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="flares.fields.ActiveRegionParameters" href="fields.html#flares.fields.ActiveRegionParameters">ActiveRegionParameters</a></li>
<li><a title="flares.fields.ActiveRegionFields" href="fields.html#flares.fields.ActiveRegionFields">ActiveRegionFields</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="flares.active_region.ActiveRegion.assert_background"><code class="name flex">
<span>def <span class="ident">assert_background</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a background mask. If background is already generated, does nothing
Background is simply <span><span class="MathJax_Preview">\neg (Umbra \cup Penumbra \cup Neutral Line)</span><script type="math/tex; mode=display">\neg (Umbra \cup Penumbra \cup Neutral Line)</script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_background(self):
    &#34;&#34;&#34;Generates a background mask. If background is already generated, does nothing
    Background is simply $$\\neg (Umbra \\cup Penumbra \\cup Neutral Line)$$
    &#34;&#34;&#34;
    if self.__background is None:
        self.__background = torch.zeros(self.shape, dtype=bool)
        self.assert_neutral_lines()
        self.assert_umbra_pumbra()

        background = ~(self.__nl | self.__umbra | self.__pumbra)

        # Update dataset
        data, labels = self.physical_features(background, &#34;bckg_&#34;)
        self.__segmented[3*self.num_features:4*self.num_features] = data
        self.__segmented_labels[3*self.num_features:4*self.num_features] = labels

        self.__background = background</code></pre>
</details>
</dd>
<dt id="flares.active_region.ActiveRegion.assert_masks"><code class="name flex">
<span>def <span class="ident">assert_masks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>One function that generates all three masks. If all three masks are already
generated, this function does nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_masks(self):
    &#34;&#34;&#34;One function that generates all three masks. If all three masks are already
    generated, this function does nothing
    &#34;&#34;&#34;
    self.__baseline, self.__baseline_labels = self.physical_features(np.ones(self.shape, dtype = bool), &#34;bas_&#34;)
    self.assert_neutral_lines()
    self.assert_umbra_pumbra()
    self.assert_background()</code></pre>
</details>
</dd>
<dt id="flares.active_region.ActiveRegion.assert_neutral_lines"><code class="name flex">
<span>def <span class="ident">assert_neutral_lines</span></span>(<span>self, radius=3, thresh=150)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates neutral lines using morphological operations and a flux threshold
finds neutral lines using the method described by Schrijver in</p>
<p><strong>C. J. Schrijver. A characteristic magnetic field pattern associated with all major solar flares and its use in flare forecasting. <em>The Astrophysical Journal, 655(2), 2007.</em></strong></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The found neutral line is one pixel thick, so dilating it slightly adds the surrounding neighborhood. This radius</dd>
<dt>is passed to sklearn.morphology.square(radius) in the call to sklearn.morphology.binary_dilation. Defaults to 3</dt>
<dt><strong><code>thresh</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Flux threshold. Defaults to 150 (as used by Schjriver et. al).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_neutral_lines(self, radius = 3, thresh = 150):
    &#34;&#34;&#34;Generates neutral lines using morphological operations and a flux threshold
    finds neutral lines using the method described by Schrijver in
    
    **C. J. Schrijver. A characteristic magnetic field pattern associated with all major solar flares and its use in flare forecasting. *The Astrophysical Journal, 655(2), 2007.***


    Args:
        radius (int, optional): The found neutral line is one pixel thick, so dilating it slightly adds the surrounding neighborhood. This radius
        is passed to sklearn.morphology.square(radius) in the call to sklearn.morphology.binary_dilation. Defaults to 3
        thresh (int, optional): Flux threshold. Defaults to 150 (as used by Schjriver et. al).
    &#34;&#34;&#34;
    if self.__nl is None:
        # Find neutral Lines
        nl_mask = binary_dilation(self.Bz &lt; -thresh, square(radius)) &amp; binary_dilation(self.Bz &gt; thresh, square(radius))


        labeled, labels, sizes = self.__group_pixels(nl_mask)
        labels, sizes = self.__remove_small_groups(labeled, labels, sizes, 10)
        labels, sizes = self.__remove_percentage_max(labeled, labels, sizes)
        labels, sizes = self.__largest_n_clusters(labels, sizes)

        # Add all the graph nodes
        nl_mask = np.zeros(self.shape, dtype = bool)
        cur_node = len(self.__node_masks)

        if len(sizes) == 0:
            self.__segmented[0:self.num_features] = 0
            self.__nl = nl_mask
            return

        for i in labels:
            mask = labeled == i
            cur_node = self.__ar_add_node(self.physical_features(mask)[0], cur_node, mask, &#34;neutral line&#34;)
            nl_mask |= mask

        # Compute the segmented data set
        data, labels = self.physical_features(nl_mask, &#34;nl_&#34;)
        self.__segmented[0:self.num_features] = data
        self.__segmented_labels[0:self.num_features] = labels
        self.__nl = nl_mask</code></pre>
</details>
</dd>
<dt id="flares.active_region.ActiveRegion.assert_umbra_pumbra"><code class="name flex">
<span>def <span class="ident">assert_umbra_pumbra</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>An original algorithm for detecting umbras and penumbras from a continuum image</p>
<p>High Level Algorithm:</p>
<ol>
<li>
<p>bound continuum between 0 and 255</p>
</li>
<li>
<p>use an adaptive filter on the bounded continuum</p>
</li>
<li>
<p>group and label touching pixels </p>
</li>
<li>
<p>remove groups of pixels that are less than 500 from those remaining (if any) </p>
</li>
<li>
<p>remove groups of pixels that border the image (usually noise) from those remaining (if any) </p>
</li>
<li>
<p>remove all groups that are smaller than 10% of the size of the maximum group size from those remaining (if any)
</p>
</li>
<li>
<p>remove take the largest 6 clusters from those remaining (if any) </p>
</li>
<li>
<p>The remaining groups are <strong>penumbra outlines</strong>, repeat the above process isolated only to the penumbra outlines
if the difference between maximum and minimum flux in the mask is greater than 21000 and the resulting clusters are umbras</p>
</li>
<li>
<p>Keep the remaining 6 largest umbras</p>
</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_umbra_pumbra(self):
    &#34;&#34;&#34;An original algorithm for detecting umbras and penumbras from a continuum image

    High Level Algorithm:

    1. bound continuum between 0 and 255

    2. use an adaptive filter on the bounded continuum

    3. group and label touching pixels 

    4. remove groups of pixels that are less than 500 from those remaining (if any) 

    5. remove groups of pixels that border the image (usually noise) from those remaining (if any) 

    6. remove all groups that are smaller than 10% of the size of the maximum group size from those remaining (if any)  

    7. remove take the largest 6 clusters from those remaining (if any) 

    8. The remaining groups are **penumbra outlines**, repeat the above process isolated only to the penumbra outlines
    if the difference between maximum and minimum flux in the mask is greater than 21000 and the resulting clusters are umbras

    9. Keep the remaining 6 largest umbras
    &#34;&#34;&#34;
    if self.__pumbra is None or self.__umbra is None:
        #We first segment large groups (that may be penumbras or umbras)
        cont_bounded = (255 * (self.cont - np.min(self.cont)) / np.ptp(self.cont)).astype(np.uint8)

        block_size = np.min(self.shape)
        if block_size % 2 == 0:
            block_size -= 1
            
        offset = 10
        binary_adaptive = cont_bounded &lt; (threshold_local(cont_bounded, block_size, offset = offset) - offset)

        labeled_0, labels, sizes = self.__group_pixels(binary_adaptive)
        labels, sizes = self.__remove_small_groups(labeled_0, labels, sizes)
        labels, sizes = self.__remove_bordering_pixels(labeled_0, labels, sizes)
        labels, sizes = self.__remove_percentage_max(labeled_0, labels, sizes)
        labels, sizes = self.__largest_n_clusters(labels, sizes)

        um_mask = np.zeros(self.shape, dtype = bool)
        pu_mask = np.zeros(self.shape, dtype = bool)
        cur_node = 0

        if len(sizes) == 0:
            self.__segmented[self.num_features:2*self.num_features] = 0
            self.__segmented[2*self.num_features:3*self.num_features] = 0
            self.__umbra = um_mask
            self.__pumbra = pu_mask
            return

        # For each large group - determine if this is a penumbra / umbra combo or just umbra
        for i in labels:
            mask = labeled_0 == i
            mx = np.max(self.cont[mask])
            mn = np.min(self.cont[mask])
            t = (mx - mn) / 2 + mn

            # PENUMBRA AND UMBRA
            if mx - mn &gt; 21000:
                # Both umbra and penumbra
                um = mask &amp; (self.cont &lt;= t)
                pu = mask &amp; (self.cont &gt; t)


                # Further segment the umbra node again
                labeled, labels, sizes = self.__group_pixels(pu)
                labels, sizes = self.__remove_small_groups(labeled, labels, sizes, 10)
                labels, sizes = self.__remove_percentage_max(labeled, labels, sizes)
                labels, sizes = self.__largest_n_clusters(labels, sizes)

                for i in labels:
                    mask = labeled == i
                    cur_node = self.__ar_add_node(self.physical_features(mask)[0], cur_node, mask, &#34;penumbra&#34;)
                    pu_mask |= mask

                # Further segment the umbra node again
                labeled, labels, sizes = self.__group_pixels(um)
                labels, sizes = self.__remove_small_groups(labeled, labels, sizes, 10)
                labels, sizes = self.__remove_percentage_max(labeled, labels, sizes)
                labels, sizes = self.__largest_n_clusters(labels, sizes)

                for i in labels:
                    mask = labeled == i
                    cur_node = self.__ar_add_node(self.physical_features(mask)[0], cur_node, mask, &#34;umbra&#34;)
                    um_mask |= mask

            # ONLY UMBRA
            else:
                um = mask &amp; (self.cont &lt;= t)
                cur_node = self.__ar_add_node(self.physical_features(mask)[0], cur_node, mask, &#34;umbra&#34;)
                um_mask |= um
        
        # Compute the segmented data set
        data, labels = self.physical_features(um_mask, &#34;um_&#34;)
        self.__segmented[self.num_features:2*self.num_features] = data
        self.__segmented_labels[self.num_features:2*self.num_features] = labels

        data, labels = self.physical_features(um_mask, &#34;pu_&#34;)
        self.__segmented[2*self.num_features:3*self.num_features] = data
        self.__segmented_labels[2*self.num_features:3*self.num_features] = labels

        self.__umbra = um_mask
        self.__pumbra = pu_mask</code></pre>
</details>
</dd>
<dt id="flares.active_region.ActiveRegion.draw_graph"><code class="name flex">
<span>def <span class="ident">draw_graph</span></span>(<span>self, axs)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws just the graph without a background image of the continuum</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axs</code></strong> :&ensp;<code>pyplot.axis</code></dt>
<dd>The axis to write the graph to</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_graph(self, axs):
    &#34;&#34;&#34;Draws just the graph without a background image of the continuum

    Args:
        axs (pyplot.axis): The axis to write the graph to
    &#34;&#34;&#34;
    self.assert_masks()

    color_keys = {&#34;penumbra&#34; : 1.0, &#34;umbra&#34; : 0.5714285714285714, &#34;nl&#34; : 0.0}
    values = [color_keys.get(x[1][&#34;type&#34;], 0.25) for x in self.__G.nodes.data()]
    nx.draw(self.__G, ax = axs, node_size = 100, cmap = plt.get_cmap(&#39;viridis&#39;), node_color = values, with_labels = False, font_color = &#34;white&#34;)</code></pre>
</details>
</dd>
<dt id="flares.active_region.ActiveRegion.get_baseline"><code class="name flex">
<span>def <span class="ident">get_baseline</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get function for baseline</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy array</code></dt>
<dd>baseline data set</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_baseline(self):
    &#34;&#34;&#34;Get function for baseline

    Returns:
        numpy array: baseline data set
    &#34;&#34;&#34;
    self.assert_masks()
    return self.__baseline, self.__baseline_labels</code></pre>
</details>
</dd>
<dt id="flares.active_region.ActiveRegion.get_graph"><code class="name flex">
<span>def <span class="ident">get_graph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the sharps data and labels</p>
<p>Sharps data is the data JSOC calculates - good baseline</p>
<h2 id="returns">Returns</h2>
<p>data, labels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_graph(self):
    &#34;&#34;&#34;Gets the sharps data and labels

    Sharps data is the data JSOC calculates - good baseline

    Returns:
        data, labels
    &#34;&#34;&#34;
    self.assert_masks()
    self.__G_labels = self.__baseline_labels # Just a copy of baseline
    return self.__G, self.__G_labels</code></pre>
</details>
</dd>
<dt id="flares.active_region.ActiveRegion.get_segmented"><code class="name flex">
<span>def <span class="ident">get_segmented</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get function for segmented</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy array</code></dt>
<dd>segmented data set</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_segmented(self):
    &#34;&#34;&#34;Get function for segmented

    Returns:
        numpy array: segmented data set 
    &#34;&#34;&#34;
    self.assert_masks()
    return self.__segmented, self.__segmented_labels</code></pre>
</details>
</dd>
<dt id="flares.active_region.ActiveRegion.get_sharps"><code class="name flex">
<span>def <span class="ident">get_sharps</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the sharps data and labels</p>
<p>Sharps data is the data JSOC calculates - good baseline</p>
<h2 id="returns">Returns</h2>
<p>data, labels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sharps(self):
    &#34;&#34;&#34;Gets the sharps data and labels

    Sharps data is the data JSOC calculates - good baseline

    Returns:
        data, labels
    &#34;&#34;&#34;
    self.assert_masks()
    return self.__sharps, self.__sharps_labels</code></pre>
</details>
</dd>
<dt id="flares.active_region.ActiveRegion.show_background"><code class="name flex">
<span>def <span class="ident">show_background</span></span>(<span>self, axs_orig, axs_seg)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows the background segmented next to the continuum</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axs_orig</code></strong> :&ensp;<code>matplotlib axis</code></dt>
<dd>The axis for the unsegmented image</dd>
<dt><strong><code>axs_seg</code></strong> :&ensp;<code>matplotlib axis</code></dt>
<dd>The axis for the segmented image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_background(self, axs_orig, axs_seg):
    &#34;&#34;&#34;Shows the background segmented next to the continuum

    Args:
        axs_orig (matplotlib axis): The axis for the unsegmented image
        axs_seg (matplotlib axis): The axis for the segmented image
    &#34;&#34;&#34;
    self.assert_masks()
    axs_orig.imshow(self.cont, cmap = &#34;gray&#34;)
    axs_seg.imshow(~self.__background, cmap = &#34;gray&#34;)
    axs_orig.axis(False)
    axs_seg.axis(False)</code></pre>
</details>
</dd>
<dt id="flares.active_region.ActiveRegion.show_graph"><code class="name flex">
<span>def <span class="ident">show_graph</span></span>(<span>self, axs_cont, axs_seg)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the continuum next to segmented graph with nodes
Located on the graph with colors</p>
<p>Note that umbras and penumbras are generally going to be very close to one another
This is because the umbra is near the center of the penumbra so their centers are going
to be close - there are a few good examples of nodes that work well - see documentation/guides</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axs_cont</code></strong> :&ensp;<code>axis</code></dt>
<dd>The continuum Axis </dd>
<dt><strong><code>axs_seg</code></strong> :&ensp;<code>axis</code></dt>
<dd>The segmented axis</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_graph(self, axs_cont, axs_seg):
    &#34;&#34;&#34;Plots the continuum next to segmented graph with nodes
    Located on the graph with colors
    
    Note that umbras and penumbras are generally going to be very close to one another
    This is because the umbra is near the center of the penumbra so their centers are going
    to be close - there are a few good examples of nodes that work well - see documentation/guides

    Args:
        axs_cont (axis): The continuum Axis 
        axs_seg (axis): The segmented axis
    &#34;&#34;&#34;
    self.assert_masks()

    color_keys = {&#34;penumbra&#34; : 1.0, &#34;umbra&#34; : 0.5714285714285714, &#34;nl&#34; : 0.0}
    values = [color_keys.get(x[1][&#34;type&#34;], 0.25) for x in self.__G.nodes.data()]
    pos = nx.get_node_attributes(self.__G, &#34;pos&#34;)

    axs_cont.imshow(self.cont)
    nx.draw(self.__G, pos, axs_cont, node_size = 100, cmap = plt.get_cmap(&#39;gray&#39;), node_color = values, with_labels = False, font_color = &#34;white&#34;)
    axs_seg.imshow(self.__umbra | self.__pumbra | self.__nl, cmap = &#34;gray&#34;)
    nx.draw(self.__G, pos, axs_seg, node_size = 100, cmap = plt.get_cmap(&#39;viridis&#39;), node_color = values, with_labels = False, font_color = &#34;white&#34;)</code></pre>
</details>
</dd>
<dt id="flares.active_region.ActiveRegion.show_neutral_line"><code class="name flex">
<span>def <span class="ident">show_neutral_line</span></span>(<span>self, axs_orig, axs_seg)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows the neutral line segmented next to the line of sight magnetic field</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axs_orig</code></strong> :&ensp;<code>matplotlib axis</code></dt>
<dd>The axis for the unsegmented image</dd>
<dt><strong><code>axs_seg</code></strong> :&ensp;<code>matplotlib axis</code></dt>
<dd>The axis for the segmented image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_neutral_line(self, axs_orig, axs_seg):
    &#34;&#34;&#34;Shows the neutral line segmented next to the line of sight magnetic field

    Args:
        axs_orig (matplotlib axis): The axis for the unsegmented image
        axs_seg (matplotlib axis): The axis for the segmented image
    &#34;&#34;&#34;
    self.assert_masks()
    axs_orig.imshow(self.Bz, cmap = &#34;gray&#34;)
    axs_seg.imshow(~self.__nl, cmap = &#34;gray&#34;)
    axs_orig.axis(False)
    axs_seg.axis(False)</code></pre>
</details>
</dd>
<dt id="flares.active_region.ActiveRegion.show_penumbra"><code class="name flex">
<span>def <span class="ident">show_penumbra</span></span>(<span>self, axs_orig, axs_seg)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows the penumbra segmented next to the continuum</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axs_orig</code></strong> :&ensp;<code>matplotlib axis</code></dt>
<dd>The axis for the unsegmented image</dd>
<dt><strong><code>axs_seg</code></strong> :&ensp;<code>matplotlib axis</code></dt>
<dd>The axis for the segmented image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_penumbra(self, axs_orig, axs_seg):
    &#34;&#34;&#34;Shows the penumbra segmented next to the continuum

    Args:
        axs_orig (matplotlib axis): The axis for the unsegmented image
        axs_seg (matplotlib axis): The axis for the segmented image
    &#34;&#34;&#34;
    self.assert_masks()
    axs_orig.imshow(self.cont, cmap = &#34;gray&#34;)
    axs_seg.imshow(~self.__pumbra, cmap = &#34;gray&#34;)
    axs_orig.axis(False)
    axs_seg.axis(False)</code></pre>
</details>
</dd>
<dt id="flares.active_region.ActiveRegion.show_umbra"><code class="name flex">
<span>def <span class="ident">show_umbra</span></span>(<span>self, axs_orig, axs_seg)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows the umbra segmented next to the continuum</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axs_orig</code></strong> :&ensp;<code>matplotlib axis</code></dt>
<dd>The axis for the unsegmented image</dd>
<dt><strong><code>axs_seg</code></strong> :&ensp;<code>matplotlib axis</code></dt>
<dd>The axis for the segmented image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_umbra(self, axs_orig, axs_seg):
    &#34;&#34;&#34;Shows the umbra segmented next to the continuum

    Args:
        axs_orig (matplotlib axis): The axis for the unsegmented image
        axs_seg (matplotlib axis): The axis for the segmented image
    &#34;&#34;&#34;
    self.assert_masks()
    axs_orig.imshow(self.cont, cmap = &#34;gray&#34;)
    axs_seg.imshow(~self.__umbra, cmap = &#34;gray&#34;)
    axs_orig.axis(False)
    axs_seg.axis(False)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="flares.fields.ActiveRegionParameters" href="fields.html#flares.fields.ActiveRegionParameters">ActiveRegionParameters</a></b></code>:
<ul class="hlist">
<li><code><a title="flares.fields.ActiveRegionParameters.B_grad_moments" href="fields.html#flares.fields.ActiveRegionParameters.B_grad_moments">B_grad_moments</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.Bh_grad_moments" href="fields.html#flares.fields.ActiveRegionParameters.Bh_grad_moments">Bh_grad_moments</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.Bz_grad_moments" href="fields.html#flares.fields.ActiveRegionParameters.Bz_grad_moments">Bz_grad_moments</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.J_moments" href="fields.html#flares.fields.ActiveRegionParameters.J_moments">J_moments</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.Jh_moments" href="fields.html#flares.fields.ActiveRegionParameters.Jh_moments">Jh_moments</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_B" href="fields.html#flares.fields.ActiveRegionFields.assert_B">assert_B</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_Bh" href="fields.html#flares.fields.ActiveRegionFields.assert_Bh">assert_Bh</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_Bp" href="fields.html#flares.fields.ActiveRegionFields.assert_Bp">assert_Bp</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_J" href="fields.html#flares.fields.ActiveRegionFields.assert_J">assert_J</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_Jh" href="fields.html#flares.fields.ActiveRegionFields.assert_Jh">assert_Jh</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_gamma" href="fields.html#flares.fields.ActiveRegionFields.assert_gamma">assert_gamma</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_grad_B" href="fields.html#flares.fields.ActiveRegionFields.assert_grad_B">assert_grad_B</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_grad_Bh" href="fields.html#flares.fields.ActiveRegionFields.assert_grad_Bh">assert_grad_Bh</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_grad_Bm" href="fields.html#flares.fields.ActiveRegionFields.assert_grad_Bm">assert_grad_Bm</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_grad_Bx" href="fields.html#flares.fields.ActiveRegionFields.assert_grad_Bx">assert_grad_Bx</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_grad_By" href="fields.html#flares.fields.ActiveRegionFields.assert_grad_By">assert_grad_By</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_grad_Bz" href="fields.html#flares.fields.ActiveRegionFields.assert_grad_Bz">assert_grad_Bz</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_hc" href="fields.html#flares.fields.ActiveRegionFields.assert_hc">assert_hc</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_rho" href="fields.html#flares.fields.ActiveRegionFields.assert_rho">assert_rho</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.assert_shear" href="fields.html#flares.fields.ActiveRegionFields.assert_shear">assert_shear</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.entropy" href="fields.html#flares.fields.ActiveRegionParameters.entropy">entropy</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.fractal_dim" href="fields.html#flares.fields.ActiveRegionParameters.fractal_dim">fractal_dim</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.gamma_moments" href="fields.html#flares.fields.ActiveRegionParameters.gamma_moments">gamma_moments</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.h_moments" href="fields.html#flares.fields.ActiveRegionParameters.h_moments">h_moments</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.hc_moments" href="fields.html#flares.fields.ActiveRegionParameters.hc_moments">hc_moments</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.hctot" href="fields.html#flares.fields.ActiveRegionParameters.hctot">hctot</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.hctotabs" href="fields.html#flares.fields.ActiveRegionParameters.hctotabs">hctotabs</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.ihtot" href="fields.html#flares.fields.ActiveRegionParameters.ihtot">ihtot</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.ihtotabs" href="fields.html#flares.fields.ActiveRegionParameters.ihtotabs">ihtotabs</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.itot" href="fields.html#flares.fields.ActiveRegionParameters.itot">itot</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.itot_polarity" href="fields.html#flares.fields.ActiveRegionParameters.itot_polarity">itot_polarity</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.itotabs" href="fields.html#flares.fields.ActiveRegionParameters.itotabs">itotabs</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.manually_add_field" href="fields.html#flares.fields.ActiveRegionFields.manually_add_field">manually_add_field</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.norm" href="fields.html#flares.fields.ActiveRegionParameters.norm">norm</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.phitot" href="fields.html#flares.fields.ActiveRegionParameters.phitot">phitot</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.phitotabs" href="fields.html#flares.fields.ActiveRegionParameters.phitotabs">phitotabs</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.physical_features" href="fields.html#flares.fields.ActiveRegionParameters.physical_features">physical_features</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.register_func" href="fields.html#flares.fields.ActiveRegionParameters.register_func">register_func</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.rho_moments" href="fields.html#flares.fields.ActiveRegionParameters.rho_moments">rho_moments</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.shear_moments" href="fields.html#flares.fields.ActiveRegionParameters.shear_moments">shear_moments</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.totrho" href="fields.html#flares.fields.ActiveRegionParameters.totrho">totrho</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.twist_moments" href="fields.html#flares.fields.ActiveRegionParameters.twist_moments">twist_moments</a></code></li>
<li><code><a title="flares.fields.ActiveRegionParameters.z_moments" href="fields.html#flares.fields.ActiveRegionParameters.z_moments">z_moments</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="flares" href="index.html">flares</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="flares.active_region.ActiveRegion" href="#flares.active_region.ActiveRegion">ActiveRegion</a></code></h4>
<ul class="">
<li><code><a title="flares.active_region.ActiveRegion.assert_background" href="#flares.active_region.ActiveRegion.assert_background">assert_background</a></code></li>
<li><code><a title="flares.active_region.ActiveRegion.assert_masks" href="#flares.active_region.ActiveRegion.assert_masks">assert_masks</a></code></li>
<li><code><a title="flares.active_region.ActiveRegion.assert_neutral_lines" href="#flares.active_region.ActiveRegion.assert_neutral_lines">assert_neutral_lines</a></code></li>
<li><code><a title="flares.active_region.ActiveRegion.assert_umbra_pumbra" href="#flares.active_region.ActiveRegion.assert_umbra_pumbra">assert_umbra_pumbra</a></code></li>
<li><code><a title="flares.active_region.ActiveRegion.draw_graph" href="#flares.active_region.ActiveRegion.draw_graph">draw_graph</a></code></li>
<li><code><a title="flares.active_region.ActiveRegion.get_baseline" href="#flares.active_region.ActiveRegion.get_baseline">get_baseline</a></code></li>
<li><code><a title="flares.active_region.ActiveRegion.get_graph" href="#flares.active_region.ActiveRegion.get_graph">get_graph</a></code></li>
<li><code><a title="flares.active_region.ActiveRegion.get_segmented" href="#flares.active_region.ActiveRegion.get_segmented">get_segmented</a></code></li>
<li><code><a title="flares.active_region.ActiveRegion.get_sharps" href="#flares.active_region.ActiveRegion.get_sharps">get_sharps</a></code></li>
<li><code><a title="flares.active_region.ActiveRegion.show_background" href="#flares.active_region.ActiveRegion.show_background">show_background</a></code></li>
<li><code><a title="flares.active_region.ActiveRegion.show_graph" href="#flares.active_region.ActiveRegion.show_graph">show_graph</a></code></li>
<li><code><a title="flares.active_region.ActiveRegion.show_neutral_line" href="#flares.active_region.ActiveRegion.show_neutral_line">show_neutral_line</a></code></li>
<li><code><a title="flares.active_region.ActiveRegion.show_penumbra" href="#flares.active_region.ActiveRegion.show_penumbra">show_penumbra</a></code></li>
<li><code><a title="flares.active_region.ActiveRegion.show_umbra" href="#flares.active_region.ActiveRegion.show_umbra">show_umbra</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>